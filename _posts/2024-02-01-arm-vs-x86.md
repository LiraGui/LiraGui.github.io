---
layout: post
title: "ARM vs x86 em Docker: Entendendo as Diferen√ßas de Arquitetura"
date: 2024-04-05 14:30:00 -0300 
categories: [docker, arm, x86]
tags: [docker, arm, x86, sre, container, linux]
author: Guilherme Lira
---

# ARM vs x86 em Docker: Entendendo as Diferen√ßas de Arquitetura

## Intro
Hoje bem sabemos que processadores de arquitetura ARM, vem se tornado cada vez mais presentes em servidores, notebooks e em gabinetes e at√© como op√ß√µes de flavors para inst√¢ncias computacionais em clouds p√∫blicas. Sabendo disso meus caros amigos e amigas, vi que podemos ter alguns pequenos desaf√≠os ao trabalhar com o nosso querido Docker. Ent√£o escrevi esse artigo pra entendermos um pouco sobre a diferen√ßa dessas arquiteturas e o que elas impactam no nosso Container Engine t√£o amado que √© o Docker.

## Diferen√ßa entre ARM e x86
A principal diferen√ßa entre processadores ARM e x86 √© que os precessadores do tipo ARM s√£o RISC e os x86 s√£o CISC. Como precisamos ter uma no√ß√£o sobre essas arquiteturas para darmos seguimeto com o artigo, irei dar uma pequena expica√ß√£o, nada muito profundo, sobre essas arquiteturas.

RISC ( Reduced Instruction Set Computer ) o que significa que suas instru√ß√µes s√£o mais reduzidas e que tendem ser mais simples e executadas em ciclos de rel√≥gio mais curtos. Uma instru√ß√£o no padr√£o RISC √© quebrada em instru√ß√µes menores para que caibam em um ciclo de rel√≥gio. Todas as instru√ß√µes tem um tamanho espec√≠fico. Diferente do CISC ( Complex Instruction Set Computer ). No modelo CISC temos instru√ß√µes mais complexas, sendo elas sem tamanho determinado podendo assumir dimens√µes vari√°veis de acordo com a quantidade de opera√ß√µes que dever√£o ser executadas.

![Image description](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/e2mx050hafivx3vfvdpy.png)

> üí° Um ciclo de rel√≥gio √© a frequ√™ncia medida em Hertz que determina quantos impulsos ser√£o realizados por segundo naquele computador.

## Como buildar uma imagem para uma arquitetura espec√≠fica
Tendo em mente que a grande maioria dos notebooks, computadores de mesa e datacenters usam processadores x86, vai ser normal gerar nossas imagens nessas m√°quinas e isso pode acarretar em alguns problemas.  
Tamb√©m partindo do pressuposto que sabemos que um container nada mais √© do que um isolamento dentro do SO ( Sistema Operacional ), e por isso ao fazer a gera√ß√£o de uma imagem, n√£o adequada, para uma m√°quina com a CPU de arquitetura diferente de onde a imagem ser√° executadada, vai acerretar nos problemas que veremos a seguir.

> üí° Geralmente imagens muito usadas como RabbitMQ, Ubuntu ou at√© NodeJs s√£o multi-plataforma, elas j√° tem imagens expecificas para cada arquitetura de CPU, ent√£o n√£o ser√° necess√°rio expecificar, veremos isso mais ao decorrer do artigo.

### Poss√≠veis erros que v√£o acontecer
Bom como vimos acima para cada tipo de arquitetura as instru√ß√µes s√£o organizadas de uma maneira espec√≠fica, ent√£o √© claro que se executarmos um "build", dentro de uma m√°quina com processador x86, e tentar executar essa imagem dentro de uma m√°quina de processador ARM, vamos ter o seguinte erro.

```sh
$ docker-compose up -d
$ ... The requested image`s platform (linux/amd64) does not match the detected host platform (linux/arm64/v8) and no specific platform was requested
```

Um ponto **muito importante**, mais pra frente do artigo veremos como fazer o build correto para cada arquitetura, mas devemos ter uma aten√ß√£o maior para as depend√™ncias do seu c√≥digo, pois, mesmo que a imagem seja criada da maneira correta, talvez as suas depend√™ncias n√£o foram buildadas para arquitetura ARM. Para resolver esse problema em NodeJs, podemos fazer da seguinte maneira, e com um simples comando:
```sh
$ npm install --cpu arm64 --os XPTO 
# Esse √© so um exemplo voc√™ pode usar o SO que quiser
```

> üí° Quando der um pull na sua imagem ser√° poss√≠vel ver para qual tipo de arquitetura sua imagem foi gerada, com o seguinte comando:
> ```sh
> $ docker image inspect rabbitmq:latest --format='{{.Architecture}}'
> arm64 # Retorno do comando
> ```
> Dessa maneira, antes mesmo de usar a imagem, podemos saber se ser√° compat√≠vel com a arquitetura da CPU, evitando erros futuros.

### Como saber a arquitetura da sua CPU
Para saber qual a arquitetura da sua CPU √© so digitar o camando, se voc√™ estiver em uma m√°quina com linux, o seguinte comando:
```sh
# Mac M1
$ uname -m
arm64 

# Maquina com processador Intel
$ uname -m
x86_64
```

### Estrat√©gias de build
Como vimos durante todo o artigo, imagens Docker podem suportar m√∫ltiplas plataformas. Isso significa que uma simples imagem do Docker pode conter variantes para diferentes arquiteturas. Mais acima comentei que quando imagens tem suporte a multi-pltaforma, o Docker automaticamente seleciona a imagem que corresponde a arquitetura e SO da m√°quina onde a imagem ser√° baixada. Sabendo disso, vamos ver duas possibilidades de criar uma imagem multi-plataforma.

Antes de come√ßarmos preciso falar um pouco sobre nosso amigo `docker buildx`, [Buildx](https://github.com/moby/buildkit) √© um componente do Docker que tem √≥timas funcionalidades para gera√ß√£o de imagem, e uma delas √© a multi-plataforma. Todas as imagens geradas por ele s√£o executadas com o [Moby Buildkit](https://github.com/moby/buildkit).  
Para fazer a cria√ß√£o de imagens multi-plataforma, antes devemos criar uma `builder instance`, para criar segue o comando abaixo:
```sh
$ docker buildx create --use
```
Ao criar uma imagem multiplataforma a partir de um Dockerfile, efetivamente seu Dockerfile √© constru√≠do uma vez para cada plataforma. No final da compila√ß√£o, todas essas imagens s√£o mescladas em uma √∫nica imagem multiplataforma.  
```docker
FROM alpine
RUN echo "Hello" > /hello
```
Por exemplo, nesse caso acima onde temos um simples Dockerfile, ao executar o comando `docker buildx build --platform=linux/amd64,linux/arm64 .`, o BuildKit vai subir duas imagens Alpine de diferentes vers√µes, uma para cada tipo de arquitetura passada no comando, e vai executar todas as camandas para cada tipo de arquitetura. Por isso, √© muito importante ter uma imagem base que tenha suporte para v√°rias arquiteturas.

#### Emula√ß√£o
Para executar esse tipo de build √© bem simples, no exemplo acima j√° ocorre com a estrat√©gia de Emula√ß√£o, onde seram literalmente emulados os comandos em containers preparados para a arquitetura desejada. Para esse tipo de estrat√©gia n√£o √© preciso altera√ß√£o no Dockerfile. √â maneira mais simples de obter uma imagem com suporte a multi-plataforma, mas com essa facilidade vem alguns problemas. Os bin√°rios executados dessa maneira precisam converter constantemente suas instru√ß√µes entre arquiteturas e, portanto, n√£o s√£o executados com velocidade nativa. Ocasionalmente, voc√™ tamb√©m pode encontrar um caso que desencadeia um bug na camada de emula√ß√£o. 
Mas o problema da estrat√©gia de emula√ß√£o n√£o vai ocorrer na Cross Compilation, que veremos a seguir.

#### Corss Compilation
Nessa estrat√©gia vamos ter um pouco mais de trabalho, vamos precisar fazer algumas altera√ß√µes dentro de um Dockerfile, vou usar um caso bem simples, que ser√° a do Alpine. Para conseguirmos uma imagem do alpine que seja mutliplataforma podemos usar algumas vari√°veis globais pr√© definidas como o BUILDPLATAFORM, ela sempre corresponder√° √† plataforma ou ao seu sistema atual e o construtor vai preencher o valor correto para gente.
```docker
FROM --platform=$BUILDPLATFORM alpine
```

> Segue a lista com todas as veriaveis:
> - BUILDPLATFORM ‚Äî Corresponde a plataforma da m√°quina atual. (linux/amd64)
> - BUILDOS ‚Äî Componente de SO da BUILDPLATFORM. (linux)
> - BUILDARCH ‚Äî Tipo de arquitetura da m√°quina atual. (amd64, arm64, riscv64)
> - BUILDVARIANT ‚Äî Usado para definir a variante ARM. (v7)
> - TARGETPLATFORM ‚Äî O valor definido com o flag --platform na compila√ß√£o
> - TARGETOS - SO definido na flag --platform. (linux)
> - TARGETARCH - Tipo da arquitetura definida na --platform. (arm64)
> - TARGETVARIANT

Vamos ver um exemplo bem simples de uma imagem com a estrat√©gia de cross compilation.
```docker
FROM --platform=$BUILDPLATFORM alpine AS build
RUN apk add mycompiler
COPY src src
ARG TARGETPLATFORM
RUN compile -target=$TARGETPLATFORM -o /out/mybinary /src

FROM alpine
RUN apk add helperapp
COPY --from=build /out/mybinary /bin
```
No Dockerfile acima conseguimos ver como vai funcionar nossa imagem. √â so uma imagem de exemplo, mas √© poss√≠vel entender que a imagem ter√° que ser desenvolvida para se adaptar e gerar seus bin√°rios de acordo com a arquitetura escolhida. Para cada linguagem de programa√ß√£o, por exemplo, existe uma maneira de gerar os pacotes ou bin√°rios, para a lingauem Go funciona da seguinte maneira, segue o exemplo:
```docker
FROM --platform=$BUILDPLATFORM golang:1.17-alpine AS build
WORKDIR /src
COPY . .
ARG TARGETOS TARGETARCH
RUN GOOS=$TARGETOS GOARCH=$TARGETARCH go build -o /out/app .

FROM alpine
COPY --from=build /out/app /bin
```
  

E √© isso pessoal, espero que esse artigo tenha ajudado voc√™s de alguma maneira.

At√© a pr√≥xima! üëã